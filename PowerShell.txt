https://learn.microsoft.com/ru-ru/powershell/scripting/learn/ps101/00-introduction?view=powershell-7.5

Пользовательские переменные

1..5 - Оператор диапазона
$mas=$mas + '1'+'2' $(1..99)
$mas += '1' '2'


Создание переменной
$<Имя_переменной> = <Значение>
Set-Variable -Name <Имя_переменной> -Value <Значение_переменной>
Просмотр переменной 
$<Имя_переменной>
Get-Variable -Name <Имя_переменной>

Встроенные перменные
$LASTEXITCODE - Содержит код выхода последнего запущенного Через ps1 процесса
$<Имя_переменной>.GetType().name - получить тип переменной 
Select-Object -InputObject $<Имя_объекта> -Property * - просмотр атрибутов объекта 
Get-Member -InputObject $<Имя_переменной> - Просмотр методов объекта

Структуры данных 

$colorPicker = @('blue','white','yellow','black') - определение массивов
$colorPicker[2] - чтение заданного элемента
$colorPicker[1..3] - чтение диапазона элементов
$colorPicker[3] = 'white' - Изменение элементов массива
$colorPicker = $colorPicker + 'orange' - Добавление элементов массива
$colorPicker += @('pink','cyan') - Добавление нескольких элементов в массив
$colorPicker = [System.Collections.ArrayList]@('blue','white','yellow', 'black') - Создане Array List
$colorPicker.Add('gray') - Добавление элемента Array List
$colorPicker.Remove('gray') - Удаление элемента Array List

__Создание Хэш таблицы__

$users = @{
abertram = 'Adam Bertram'
raquelcer = 'Raquel Cerillo'
zheng21 = 'Justin Zheng'
}
$users['abertram'] - Чтение из Хэш таблицы
$users.abertram - Чтение из Хэш таблицы
$users.Keys - Читение ключей
$users.Value - Читение значений
Select-Object -InputObject $yourobject -Property * Все свойсва Хэш таблицы
Get-Member -InputObject $yourobject Свойства и методы объекта

Массивы (Объявление через $mas = @('1','2','3')

$mas = @('1','2','3')
$mas[1]

Множества (Лучше работают с большими данными)

$arrays = [System.Collections.ArrayList]@('1','2','3','4','5') Созание множества
$arrays.Add('1') Добавление элемента в множество
$Null = $arrays.Remove('1') Удаление элемента множеества
$arrays.Remove('1') Удаление элемента множеества

Хэш-таблицы (Ключ-значение)

Объявление Хэш-таблицы
$hashtable =@{  
Popov='Andrey'
Silchenko = 'Dmitry'
Popov2 = 'Kirull'
}

$haschtable.Popov Обращение к элементу хэш-тблицы по ключу
$hashtable.Keys Получение всех ключей
$hastable.Values Получение всех значний
Select-Object -InputObject $hashtable -Property * Все свойства Хэш-таблицы
$hashtable.Add('123', '456') Добавление пары ключ-значение в Хэш-таблицу
$hashtable.ContainsKey('Popov') Проверка на наличие ключа
$hashtable.ContainsValue('Andrey') Проверка на наличие значния
$hashtable['Popov'] = 'Drew' Замена значения по ключу
$hashtable.Remove('123') Удаление элемента по ключу

Пользовательские объекты

$MyObject = New-Object -TypeName PSCustomObject Хуёвое создание пользовательского Объекта
$MyObject = [PSCustomObject]@{OSName=$(hostname); OSVersion='B'} Создание пользовательского Объекта

З Объединение команд

Get-Service -Name Wazuh | Start-Service Запуск службы перехватом выаода
Start-Service $(GetService -Name Wazuh) Тоже самое и хуй знает какая вообще разница
Get-Content -Path C:\1.txt Просмотр содержимого файла построчно добавляя строки в масиив
Привязка параметров
Invoke-Expression $(Get-Content -Path D:\1.ps1) - Обход политики запуска скриптов (Set-ExecutionPolicy) Построчно читает файл запуская команды поочередно. Подойдёт не для любого скрипта...
Get-Help -Name <Команда> –Full - Поле Acceptpipelineinput (в русской локализированной версии PowerShell «Принимать входные данные конвейера?») говорит о возможности принимать конвейер.

$serviceObject = [PSCustomObject]@{Name = 'wuauserv'; ComputerName = 'SERV1'} - Созданный объект передаётся в команду
$serviceObject | Get-Service                                                  - -Name wuauserv -Computername SERV1

Операторы сравнения 
-eq сравнивает два значения и возвращает True, если они равны.
-ne сравнивает два значения и возвращает True, если они не равны.
-gt сравнивает два значения и возвращает True, если первое больше второго.
-ge сравнивает два значения и возвращает True, если первое больше или равно второму.
-lt сравнивает два значения и возвращает True, если первое меньше второго.
-le сравнивает два значения и возвращает True, если первое меньше или равно второму.

If
if(<Условие>){<Выполняемый код>}elseif(){}else{}

Switch
switch(<Условие>){<Значение> {<Код>} <Значение> {<Код>} default {<Код>}}

foreach 
foreach($i in $(1..100)){$i}

ForEach-Object
ForEach-Object -InputObject $<Класс_или_переменная> -Process {$_} - Одинаковая реализация циклов
$my.ForEach({$_})                                                 - действия могут производиться с объектами 

цикл for
for ($i = 1; $i -le 2025; $i++){Write-Host "число $i"}

циел while 
while (<условие>) {<код (при надобности используем break)>} 

Циклы do/while и do/until
do {<код>} while (<условие>)
do {<код>} until (<условие>)

5. ОБРАБОТКА ОШИБОК 
ОБРАБОТКА НЕЗАВЕРШАЮЩИХ ОШИБОК
Error-Action 
имеет приоретет над $ErrorActionPreference
• Continue: выводит сообщение об ошибке и продолжает выполнение командлета. Является значением по умолчанию.
• Ignore: продолжает выполнение командлета без вывода ошибки и ее записи в переменную $Error.
• Inquire: выводит сообщение об ошибке и предлагает пользователю ввести данные перед продолжением.
• SilentlyContinue: продолжает выполнение командлета без вывода сообщения об ошибке, но записывает ее в переменную $Error.
• Stop: выводит сообщение об ошибке и останавливает выполнение командлета.

 try/catch/finally
try {} catch {} finally {}  -   С помощью конструкции try/catch/finally вы словно «подстилаете соломы» для обработки ошибок. Блок try содержит исходный код, который надо запустить. Если возникает завершающая ошибка, PowerShell перенаправляет поток выполнения в блок catch. Независимо от того, выполнится ли код в блоке catch, код в блоке finally будет выполняться всегда. finally {} не является обязательной частью конструкции 

6. ФУНКЦИИ
Объявление функции 
function Get-Func{Write-Host "Ебать я функция"}  
[CmdletBinding]

Пример функции 
Function Get-Ff{ 
[CmdletBinding()]             # Говорит что функция "продвинутая" и использует командлеты
param(                        # Тут начало блока инициализации парамертов
[Parameter(ValueFromPipeline)]# Объявление первого параметра (ValueFromPipeline переменная берёт данные из пайплайна) 
[int[]]$val1,                 # ЗАканчиваем объявлять первый параметр(запятая обязательна)
[Parameter()]
[string[]]$val2 = @(9,8,7)    # Инициализация переменной в случае отсутсвия её в виде аргумента при вызове функции 
)
begin{$a=123; clear}          #(Необязательно) Код выполняется перед выполнением функции 
process{                      #(Необязательно) Код работающий при пайалайне
    Write-Host "val1 = $val1, val2 = $val2"
    foreach($i in $val2)
        {Write-Host "val2 = $i"}
    }
end {[int]$r =$(Read-Host "ебать "); $r+=1 ;Write-Host "$r"} #(Необязательно) Код работающий после выполнения функции
}

@(1,2,3; 4,5,6), @(1,2) | Get-Ff -val2 1,44,4466,66,6,66,6,6,6 #Соответственно вызов самой функции 

7. Модули
• Системные модули: почти все модули, которые идут в комплекте с PowerShell, будут расположены в папке C:\Windows\System32\WindowsPowerShell\1.0\Modules. Этот путь обычно используется только для внутренних PowerShell-модулей. В принципе, вы можете размещать в этой папке и свои модули, но делать это не рекомендуется.
• Модули, доступные всем пользователям: модули также хранятся в папке C:\ProgramFiles\WindowsPowerShell\Modules. Этот путь обычно называют путем «Для всех пользователей», и именно здесь находятся все модули, которые должны быть доступны всем пользователям системы.
• Модули текущего пользователя: наконец, вы можете хранить модули в папке C:\Users\<ТекущийПользователь>\Documents\WindowsPowerShell\Modules. Внутри этой папки вы найдете все созданные или загруженные вами модули, которые доступны только текущему пользователю. Размещение модулей по этому пути позволяет разделить их на случай, если за компьютером работают несколько пользователей.

 $env:PSModulePath
