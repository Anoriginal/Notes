https://learn.microsoft.com/ru-ru/powershell/scripting/learn/ps101/00-introduction?view=powershell-7.5

Пользовательские переменные

1..5 - Оператор диапазона
$mas=$mas + '1'+'2' $(1..99)
$mas += '1' '2'


Создание переменной
$<Имя_переменной> = <Значение>
Set-Variable -Name <Имя_переменной> -Value <Значение_переменной>
Просмотр переменной 
$<Имя_переменной>
Get-Variable -Name <Имя_переменной>

Встроенные перменные
$LASTEXITCODE - Содержит код выхода последнего запущенного Через ps1 процесса
$<Имя_переменной>.GetType().name - получить тип переменной 
Select-Object -InputObject $<Имя_объекта> -Property * - просмотр атрибутов объекта 
Get-Member -InputObject $<Имя_переменной> - Просмотр методов объекта

Структуры данных 

$colorPicker = @('blue','white','yellow','black') - определение массивов
$colorPicker[2] - чтение заданного элемента
$colorPicker[1..3] - чтение диапазона элементов
$colorPicker[3] = 'white' - Изменение элементов массива
$colorPicker = $colorPicker + 'orange' - Добавление элементов массива
$colorPicker += @('pink','cyan') - Добавление нескольких элементов в массив
$colorPicker = [System.Collections.ArrayList]@('blue','white','yellow', 'black') - Создане Array List
$colorPicker.Add('gray') - Добавление элемента Array List
$colorPicker.Remove('gray') - Удаление элемента Array List

__Создание Хэш таблицы__

$users = @{
abertram = 'Adam Bertram'
raquelcer = 'Raquel Cerillo'
zheng21 = 'Justin Zheng'
}
$users['abertram'] - Чтение из Хэш таблицы
$users.abertram - Чтение из Хэш таблицы
$users.Keys - Читение ключей
$users.Value - Читение значений
Select-Object -InputObject $yourobject -Property * Все свойсва Хэш таблицы
Get-Member -InputObject $yourobject Свойства и методы объекта

Массивы (Объявление через $mas = @('1','2','3')

$mas = @('1','2','3')
$mas[1]

Множества (Лучше работают с большими данными)

$arrays = [System.Collections.ArrayList]@('1','2','3','4','5') Созание множества
$arrays.Add('1') Добавление элемента в множество
$Null = $arrays.Remove('1') Удаление элемента множеества
$arrays.Remove('1') Удаление элемента множеества

Хэш-таблицы (Ключ-значение)

Объявление Хэш-таблицы
$hashtable =@{  
Popov='Andrey'
Silchenko = 'Dmitry'
Popov2 = 'Kirull'
}

$haschtable.Popov Обращение к элементу хэш-тблицы по ключу
$hashtable.Keys Получение всех ключей
$hastable.Values Получение всех значний
Select-Object -InputObject $hashtable -Property * Все свойства Хэш-таблицы
$hashtable.Add('123', '456') Добавление пары ключ-значение в Хэш-таблицу
$hashtable.ContainsKey('Popov') Проверка на наличие ключа
$hashtable.ContainsValue('Andrey') Проверка на наличие значния
$hashtable['Popov'] = 'Drew' Замена значения по ключу
$hashtable.Remove('123') Удаление элемента по ключу

Пользовательские объекты

$MyObject = New-Object -TypeName PSCustomObject Хуёвое создание пользовательского Объекта
$MyObject = [PSCustomObject]@{OSName=$(hostname); OSVersion='B'} Создание пользовательского Объекта

З Объединение команд

Get-Service -Name Wazuh | Start-Service Запуск службы перехватом выаода
Start-Service $(GetService -Name Wazuh) Тоже самое и хуй знает какая вообще разница
Get-Content -Path C:\1.txt Просмотр содержимого файла построчно добавляя строки в масиив
Привязка параметров
Invoke-Expression $(Get-Content -Path D:\1.ps1) - Обход политики запуска скриптов (Set-ExecutionPolicy) Построчно читает файл запуская команды поочередно. Подойдёт не для любого скрипта...
Get-Help -Name <Команда> –Full - Поле Acceptpipelineinput (в русской локализированной версии PowerShell «Принимать входные данные конвейера?») говорит о возможности принимать конвейер.

$serviceObject = [PSCustomObject]@{Name = 'wuauserv'; ComputerName = 'SERV1'} - Созданный объект передаётся в команду
$serviceObject | Get-Service                                                  - -Name wuauserv -Computername SERV1

Операторы сравнения 
-eq сравнивает два значения и возвращает True, если они равны.
-ne сравнивает два значения и возвращает True, если они не равны.
-gt сравнивает два значения и возвращает True, если первое больше второго.
-ge сравнивает два значения и возвращает True, если первое больше или равно второму.
-lt сравнивает два значения и возвращает True, если первое меньше второго.
-le сравнивает два значения и возвращает True, если первое меньше или равно второму.

If
if(<Условие>){<Выполняемый код>}elseif(){}else{}

Switch
switch(<Условие>){<Значение> {<Код>} <Значение> {<Код>} default {<Код>}}

foreach 
foreach($i in $(1..100)){$i}

ForEach-Object
ForEach-Object -InputObject $<Класс_или_переменная> -Process {$_} - Одинаковая реализация циклов
$my.ForEach({$_})                                                 - действия могут производиться с объектами 

цикл for
for ($i = 1; $i -le 2025; $i++){Write-Host "число $i"}

циел while 
while (<условие>) {<код (при надобности используем break)>} 

Циклы do/while и do/until
do {<код>} while (<условие>)
do {<код>} until (<условие>)

5. ОБРАБОТКА ОШИБОК 
ОБРАБОТКА НЕЗАВЕРШАЮЩИХ ОШИБОК
Error-Action 
имеет приоретет над $ErrorActionPreference
• Continue: выводит сообщение об ошибке и продолжает выполнение командлета. Является значением по умолчанию.
• Ignore: продолжает выполнение командлета без вывода ошибки и ее записи в переменную $Error.
• Inquire: выводит сообщение об ошибке и предлагает пользователю ввести данные перед продолжением.
• SilentlyContinue: продолжает выполнение командлета без вывода сообщения об ошибке, но записывает ее в переменную $Error.
• Stop: выводит сообщение об ошибке и останавливает выполнение командлета.

 try/catch/finally
try {} catch {} finally {}  -   С помощью конструкции try/catch/finally вы словно «подстилаете соломы» для обработки ошибок. Блок try содержит исходный код, который надо запустить. Если возникает завершающая ошибка, PowerShell перенаправляет поток выполнения в блок catch. Независимо от того, выполнится ли код в блоке catch, код в блоке finally будет выполняться всегда. 



